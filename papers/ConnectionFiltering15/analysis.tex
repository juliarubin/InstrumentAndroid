\section{Detecting Non-Essential Connections}
\label{sec:analysis}

\begin{table}[t]
\renewcommand*{\arraystretch}{1.3}
\caption{Considered UI Elements.}
\label{tbl:ui}
\centering
\tabcolsep=1.5pt
%\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|P{3.5cm}|P{3.8cm}|}
\hline
& \textbf{Class or Interface} & \textbf{Methods} \\
\hline
1. & android.app.Dialog                                 & setContentView \\
2. & android.support.v7.app.\newline{}ActionBarActivityDelegate   & setContentView \\
3. & android.view.View                                  & onLayout, layout, onDraw, onAttachedToWindow \\
4. & android.view.ViewGroup                             & addView, addFocusables, addTouchables, addChildrenForAccessibility \\
5. & android.view.ViewManager                           & addView, updateViewLayout \\
6. & android.view.\newline{}WindowManagerImpl\newline{}\$CompatModeWrapper  & addView \\
7. & android.webkit.WebView                             & loadData, loadDataWithBaseURL, loadUrl \\
8. & android.widget.TextView       & append, setText \\
9. & android.widget.Toast        & makeText \\
\hline
\end{tabular}
%}%resizebox
\end{table}

In this section we describe the static analysis algorithm we employ to
automatically classify connections.  Given an Android application, the
static analysis classifies each statement that may invoke a
connection call as either {\it essential} or {\it non-essential}.
Intuitively, we define an essential connection statement, $s$, as
meeting either of the following criteria:

\begin{enumerate}
\item{\bf User-Interface Cue}: When $s$ triggers an error, the user
may be notified of the error via a user interface cue during error
handling.
\item {\bf Program Exit}: When $s$ triggers an error, the program 
   may stop executing.  
\end{enumerate}

\noindent Conversely, a non-essential connection call does not meet
either of the two criteria.  

Android applications are developed in Java, and program execution
follows the semantics of Java. In an Android application, each
connection call $s$ may generate an exception (of dynamic type $e$)
that reaches a subset of the program's \lstinline!catch! blocks.  At
runtime, when $e$ is triggered by $s$, the executing method's trap
table is consulted, and if no \lstinline!catch! blocks are defined to
handle $e$ at $s$, then $e$ is passed back up the stack, to the
calling method at the calling statement, and the process repeats.  If
the Android runtime is returned to during the stack unwinding, the
application is typically exited with an error.  

\noindent\textsc{\bfseries{Definition (Rethrown Exception)}}.  A
rethrown exception occurs when a \lstinline!catch! block catches an
exception, but before the block is exited, a statement reachable from
the block explicitly throws the same exception object, or throws a new
exception object.  The process of searching the stack for a handler
begins anew.

\begin{figure}
    \begin{lstlisting}[numbers=left, escapeinside={(*@}{@*)}]
public class Example {
    void f() {
        try {
            g();
            (*@{\it stmtA};@*)
        } catch (MyException e) {
            (*@{\it stmtB};@*)
        }
        (*@{\it stmtC};@*)
    }

    void g() throws MyException {
        try {
            (*@{\it stmtD};@*)
            connect();  //throws RemoteException (*@\label{connect-fig}@*)
            (*@{\it stmtE};@*)
        } catch (RemoteException e) {
            (*@{\it stmtF};@*)
            throw new MyException();            
        }        
        (*@{\it stmtG};@*)
    }
}
\end{lstlisting}
\caption{\label{fig:failure-handling}An example of failure handling of
}
\end{figure}

\noindent\textsc{\bfseries{Definition (Failure Handling)}}. The
failure handling of a connection call $s$ for exception type $e$ is
defined as the execution path that starts when an exception of type
$e$ propagates to connection call $s$ and ends with the statement
immediately when the last \lstinline!catch! block is exited that
handles $e$ or any rethrown exceptions of $e$.

Intuitively, the failure handling of $s$ on $e$ is the computation
that handles $e$ and any failure triggered by the handling of $e$
(through rethrown exceptions).  Failure handling is finished when all
exceptions triggered by $e$ are handled and flow returns to ``normal''
execution.  

Figure~\ref{fig:failure-handling} lists a small Java example to
illustrate failure handling.  Method \lstinline!f! invokes method
\lstinline!g!.  In \lstinline!g!, a connection call is encountered on
line~\ref{connect-fig}; assume during execution this connection call
throws a \lstinline!RemoteException!.  The failure handling for this
combination of connection call and exception is the set of statements:
{\it stmtF}, \lstinline!throw new MyException()!, and {\it stmtB}.
These statements are executed from the start of the handling of thrown
\lstinline!RemoteException! to the end of the handling of the rethrown
\lstinline!MyException!.

\noindent\textsc{\bfseries{Problem}}: \todo{finish this}

Our static failure-handling analysis conservatively calculates all
possible failure handling for exceptions that denotes connection
failure for each connection call in the application.  It also
determines whether it is possible for an exception to propagate back
into the Android runtime during error handling. \todo{finish this}

Our analysis inspects the behavior of a connection call's failure
handling of exceptions that indicate a connection failure.  If there
exists a failure-handling path of $s$ on $e$ that may include a call
to a method that notifies the user of the failure, then $s$ is
considered essential.  Furthermore, if it is possible for $e$, when
triggered at $s$, to propagate back up the stack to the Android
runtime, $s$ is considered essential.


\subsection{Static Analysis of Android Applications}

Android applications are developed in Java and compiled to Dalvik byte
code.  Android applications are distributed as packages that do not
include the Java source; packages include only the Dalvik byte code
and application resources such as images, sounds, and GUI
declarations.  Static analysis of Android applications is notoriously
difficult because of issues including~\cite{Gordon:Kim:Perkins:Gilham:Nguyen:Rinard:NDSS15}: 

\begin{itemize}

\item Android applications execute in the context of the Android API
  and runtime.  The application thus represents an incomplete program.
  
\item The Android API and runtime comprises multiple millions of lines of
  code implemented in multiple programming languages.  Furthermore,
  much of the implementation is left for device manufactures to
  implement, and is thus proprietary and closed-source. 

\item Applications are event-driven and dynamic by nature.
  Applications define event handlers for possible runtime events that
  are triggered in the Android runtime, and passed to the application
  for handling. 

\item Applications interact heavily with the Android API.  The Android
  API includes most of the Java standard library, plus additional
  utility and resource access classes.

\item Android application packages typically ship with third-party
  libraries for performing operations such as advertising, analytics,
  and interaction with remote services.  These libraries are commonly
  large, obfuscated, and include heavy use of reflection.

\end{itemize}

It is not feasible for a static analysis to include analysis of the
source code of the Android runtime and API because of the size and
multi-language nature of this code base.  Thus static analysis must
either model the Android application execution environment, or account
for possible dynamic program behaviors with conservative analysis
choices.  We choose the later strategy in our analysis to account f

\subsection{Call Graph Construction}

Our algorithm computes a static call graph as the program
representation of the Android application.  A call graph represents
the possible dynamic calling relationship between methods of the
application.  Each node represents a method, and each edge, $(f,g)$
indicates that $f$ may call $g$ at run time.  

Something~\cite{Fu2007}.

* unchecked exceptions


\subsection{Reconstructing {\ttfamily{catch}} Blocks}


\begin{algorithm}
\caption{Find \lstinline!catch! blocks for exception throw at statement.}\label{alg:findcatches}
\begin{algorithmic}[1]
\algblockdefx[HEADER]{inputdef}{outputdef}[1]%
{\textbf{Input}: #1}[1]{\textbf{Output}: #1}
\Procedure{FindCatches}{meth, stmt, ex, visiting, stack, cg}

\If {(stmt, ex) $\in$ visiting || (stmt, ex) $\in$ essential}
    \State \textbf{return}
\EndIf

\State visiting $\gets$ visiting $\cup$ (stmt, ex)

\State catchBlockStart $\gets$ \textsc{FindCompatCatch}(meth, stmt, ex)

\If {catchBlockStart $=$ \textbf{null} }
\If {\textsc{IsEventHandler}(meth)}
\State essential $\gets$ essential $\cup$ (stmt, ex)
\State \textbf{return}
\EndIf
\For { (predStmt, predMeth) $\in$ \textsc{GetPreds}(cg, meth)}

\If {stack $\neq \emptyset$ \textbf{and} (predStmt, predMeth) $\neq$ \textsc{Peek}(stack)}
\State \textbf{continue}
\EndIf 

\State newStack $\gets$ stack
\State \textsc{Pop}(newStack)

\State \textsc{FindCatches}(predMeth, predStmt, ex, 
\State         \hspace{2cm}visiting, newStack, cg)
\If {(predStmt, ex) $\in$ essential}
\State essential $\gets$ essential $\cup$ (stmt, ex)
\State \textbf{return}
\EndIf
\EndFor
\Else 
\State catchStmts $\gets$ \textsc{GetCatchStmts}(catchBlockStart)
\State \textsc{AnalyzeHandling}(meth, stmt, catchStmts,
\State \hspace{2cm}visiting, $\emptyset$, stack, cg)
\EndIf

\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Analyze reachable statements during handling for UI
  interaction or rethrown exceptions.}\label{alg:analyzehandler}
\begin{algorithmic}[1]
\algblockdefx[HEADER]{inputdef}{outputdef}[1]%
{\textbf{Input}: #1}[1]{\textbf{Output}: #1}
\Procedure{AnalyzeHandler}{meth, exceptStmt, stmts, 
       visiting, handledStmts, stack, cg}
\If {stmts $\in$ handledStmts}
\State \textbf{return}
\EndIf
\State handledStmts $\gets$ handledStmts $\cup$ stmts

\For {each stmt $\in$ stmts}
\If {\textsc{HasInvoke}(stmt)}
\For {(succStmt, succMeth) $\in$ \textsc{GetSuccs}(cg, stmt)}
\If {\textsc{IsUIMethod}(succMeth)}
\State essential $\gets$ essential $\cup$ exceptStmt
\State \textbf{return}
\Else 
\State newStack $\gets$ stack
\State \textsc{Push}(newStack, (succStmt, succMeth))
\EndIf 

\EndFor
\ElsIf {\textsc{IsThrowStmt}(stmt)}
\State s
\EndIf
\EndFor

\EndProcedure
\end{algorithmic}
\end{algorithm}
