\vspace{0.05in}
\section{Limitations and Threats to \\Validity}
\label{sec:limitations}
%In this section we discuss the limitations of our empirical study and our static technique for detecting non-essential connections.

%\vspace{0.05in}
%\noindent 
\subsubsection{Empirical Study}
Our empirical study has a dynamic nature and thus suffers from the well-known limitations of dynamic analysis: it does not provide an exhaustive exploration of an application's behavior, thus the findings apply only to the execution paths explored during the analysis. 
Even though we made an effort to cover all application functionality visible to us, we probably missed some behaviors, e.g., those triggered under system settings different from ours. 
We attempted to mitigate this problem by performing all our dynamic experiments on the same device, at the same location and temporally close to each other.  
We also automated our execution scripts in order to compare behaviors of different application versions under the same scenario and settings. 
We only report on the results comparing these similar runs.  

During our analysis, we disabled connections one by one, iterating over their list arranged in a lexicographic (i.e., semantically random) order. As such, we could miss cases when 
several connections can be excluded altogether, but not individually. 
Since exploring all connection state combinations is exponential, we opted for this linear approach that still guarantees correct, 
albeit possibly over-approximate results. Moreover, by focusing on individual connection statements, we cannot distinguish between multiple application behaviors
that communicate via the same statement in code. We thus conservatively deem a connection as essential if it is essential for at least one of such behaviors. 
%Exploring more sophisticated techniques for distinguishing between such different behaviors could be a subject of a possible future work.
 
Finally, our study only includes a limited number of subjects, so the results might not generalize to other applications.
We tried to mitigate this problem by not biasing our application selection but rather selecting top-popular applications from the Google Play store, and by ensuring that we observe similar communication patterns in all analyzed applications.

%\vspace{0.05in}
%\noindent 
\subsubsection{A Static Technique For Detecting Non-Essential Connections}
Our technique deems \emph{optional} behaviors -- those when failing connections are ignored by the application, but successful connections result in presenting additional information to the user -- as non~essential. 
As an application can proceed when optional behaviors are excluded, it is debatable whether they are really essential for the application functionality or not. 
In fact, we believe that it is up to the users to decide whether an optional behavior is indeed essential for their needs. 
%Towards this end, we plan to investigate approaches for differentiating between optional and ``truly non-essential'' behaviors as part of a future work. 

Our technique also deems as non-essential \emph{stateful} communication that toggles
the state of a connection target but does not perform any operations in
fault-processing code. In many cases, detecting such
communication statically is impossible because the code executed on
the target is unknown and unavailable.  Even when communication is
performed via RPC within the same application, it is exceedingly
costly for an analysis to determine, with precision, whether a
connection (or set of connections) is stateful. 
%As such cases are
%rare, developing these approaches, orthogonal to our current analysis,
%is also left to future work.
 
Some of the non-essential connections that we identified statically might never be triggered dynamically. In fact, our empirical study shows that only less than 5\% of the connection statements in the analyzed applications were indeed triggered.
Some of such connections belong to execution paths that were not explored during our dynamic application traversal.
Yet, a large percentage of these connections originate in  
third-party libraries that are included in the application but only partially used. 
Analyzing them is still beneficial as this code might be used in other applications.
Nevertheless, our approach could be combined with techniques for detecting dead code, to provide better results.
