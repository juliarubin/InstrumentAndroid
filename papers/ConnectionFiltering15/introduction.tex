\section{Introduction}
\label{sec:intro} 
Mobile applications enjoy almost permanent connectivity and the ability to exchange information with their own back-end, third-party servers and other applications installed on the same device. 
During such information exchange, applications often release sensitive information about their users, e.g., location, phone number or unique device id~\cite{Enck:Gilbert:Chun:Cox:Jung:McDaniel:Sheth:OSDI10, Egele:Kruegel:Kirda:Vign:NDSS11,Tripp:Rubin:SEC14}. 
With privacy being an increased concern, multiple works propose approaches for tracking the release of 
sensitive information~\cite{Enck:Gilbert:Chun:Cox:Jung:McDaniel:Sheth:OSDI10,Egele:Kruegel:Kirda:Vign:NDSS11,Arzt:Rasthofer:Fritz:Bodden:Bartel:Klein:Traon:Octeau:McDaniel:PLDI14, Tripp:Rubin:SEC14,Gordon:Kim:Perkins:Gilham:Nguyen:Rinard:NDSS15}. Follow-up works investigate the
feasibility of obfuscating or blocking it completely~\cite{Hornyack:Han:Jung:Schechter:Wetherall:CCS11}.

Yet, users often deliberately trade their privacy for receiving a desired service from an application, 
e.g., getting navigation instructions starting at their current location. 
In such cases, preventing the release of the location information would render an application privacy-preserving but effectively useless.
%Permission systems of contemporary mobile platforms cannot prevent an application that obtains a user consent to access sensitive data from release it to unauthorized third parties
% Once an application gains access to the user's sensitive information, it can, in addition to utilizing the information for the purpose assumed by the user, also .
%Permission systems of contemporary mobile platforms cannot distinguish between these different usages as they only require applications to declare the \emph{type} of information they want to access, not the \emph{purpose} of the access. and have no means to capture the ``semantics'' of its use. 
Existing approaches cannot distinguish between information releases that are \emph{essential} for the desired application functionality and those that are not: 
they flag each release of sensitive information as a potential privacy breach, regardless of its designated use.
The non-trivial task of classifying the \emph{purpose} of each information release is then left to the user. 


% This paper takes a step towards performing such classififction  
%This paper aims at distinguishing between these two types of information releases -- those that are expected and are essential for the desired application functionality and those that are not.  
%Specifically, we focus on identifying communication that can be eliminated without any noticeable impact on the application's functionality. 
%Specifically, we explore the impact of information exchange denial on the behavior of application. 
%An empirical analysis of multiple top-popular Android application from the Google Play store reveals that, in many cases, 
%connection failures are   silently ignored by an application or written to the log file, without 
%any noticeable effect on the application executions.
%In fact, only around 10\% of connection sites exercised by the analyzed applications directly contribute to the user-observable application functionality.

This paper makes a step towards performing such distinction automatically, 
by looking at the impact of the communication established by an application on the application's user-observable behavior. 
We rely on the assumption that for most mobile applications available in popular application stores, such as Google Play, 
preserving user-observable behavior can be seen as the main factor determining the necessity of information release. 

Our in-depth investigation of ten top-popular Android applications from Google Play shows that non-essential communication 
%which does not affect user-observable behavior 
is surprisingly common.
In fact, we noticed that some applications spawn services that communicate with third-party servers even when the application itself is no longer active and the user has no clue that some of its services are still running in the background. 
Identifying such communication helps improving transparency; disabling it helps to save, often expensive, communication bandwidth and to eliminate potential privacy breaches. 
In our analysis, the only application out of ten that leaked the unique device id to the internet did that via such a hidden connection.
Disabling the connection eliminated the information leakage without affecting the application behavior and other communication operations that the application performed.

%Towards this end,  
%%TWe empirically investigate the impact of connection denials on the overall behavior of ten top-popular Android applications from the Google Play store.
%we devise a static application analysis technique for identifying statements that can be deemed \emph{non-essential}: their failure are silently ignored by the applications
%without interfering the applications' behavior. 

The work presented in this paper aims at answering the following research questions.

\vspace{0.1in}
\noindent 
{\bf RQ1: Does non-essential communication occur in real-life applications?}
To get an  estimate on the significance of the problem, we conduct an empirical study 
that focuses on identifying and investigating the nature of non-essential communication in ten top-popular applications in Google Play. 
We focus on the three most common connection types: HTTP, socket and RPC.
The former two are used to communicate with various backend servers -- the application's own and third parties'; 
the latter one is used to communicate with other applications and services running on the same device.

Our study is dynamic in nature and is performed in three phases. 
In the first phase, we establish a baseline application behavior. 
Similarly to the approach in~\cite{Hornyack:Han:Jung:Schechter:Wetherall:CCS11}, we record a script triggering the application functionality via a series of interactions with the application's user interface. 
After each interaction, we capture a screenshot of the device to record the application state. 

In the second phase, we instrument the application to log information about 
triggered connection statements. The instrumented apk is then installed and executed on a mobile device using the recorded script. 

In the third phase, we investigate the impact of each triggered connection on the overall behavior of the application.
Specifically, we iterate over all triggered connections, producing a new version of the application with each corresponding connection being disabled. Connection disabling is achieved by replacing the connection statement with a
statement that indicates connection failure, e.g., that throws an exception that occurs when the connection fails due to the device being put in airplane mode. 
We then install the modified application and run it using the previously recorded script. The screenshots documenting 
the execution of the modified application are compared to those of the original one. We consider executions as equivalent if they result in screenshots that differ only in the content of advertisement information, messages in social network applications such as twitter, and the device's status bar. 
We also separately note connections that contribute to presenting advertisement content, if the analyzed application has any. 

Our study reveals that around 65\% of the connection statements exercised by the applications do not lead to any noticeable effect on the observable application functionality.
Slightly more than 25\% of these correspond to HTTP and socket communication. The rest correspond to RPC calls to internal services installed on the device: notably, but not exclusively, Google advertising and analytics, which further communicate with external services. 
Moreover, in applications that present advertisement material, about 60\% of the connections that do affect the observable application behavior are used for advertising purposes only.

\vspace{0.1in}
\noindent 
{\bf RQ2: Can non-essential communication be detected statically?}
While the technique that we used during the empirical study allowed us to gain deeper insights onto the nature of communication that applications perform, it clearly cannot scale up to thousands of applications available on the market today.
We thus investigate the possibility to perform such analysis in a static manner. 
 
One of the conclusions from our study is that neither the type nor the target of communication are sufficient for distinguishing between essential and non-essential connections.
% In a sense, our finding are consistent with~\cite{Hornyack:Han:Jung:Schechter:Wetherall:CCS11}, where authors show that blocking messages to advertising and analytics services made a majority the applications either less functional or completely dysfunctional, so the connection target by itself is not a sufficient distinguishing factor. 
A manual byte code inspection of the identified non-essential connections shows that failures are often either silently ignored by the application, e.g., with an empty exception \emph{catch} block, or written to a log file without being propagated to the user. 
This behavior is indicative for the connections being \emph{non-essential} for the application behavior and, in some cases, even harmful. 

Inspired by the findings, we devise a static application analysis
technique for detecting connection failures that are ``silently''
ignored by the application, i.e., when information about a connection
failure is not propagated back to the end user.  The static analysis
classifies each connection call by inspecting the execution of the
application during {\it failure handling} of the connection call.
Failure handling begins when the exception is propagated to the
connection call and ends when the execution exits the exception
handler of the exception or the handlers or all rethrown exceptions
that are raised during handling.  Intuitively, the failure handling
execution corresponds to how an application responds a failure at a
connection.  If a failure handling execution of a connection call
could affect the user interface through a call to a predefined set of
API calls, then we classify the connection call to be essential.
Also, if there is a failure handing path that could exit the program,
because a thrown exception propagates back into the Android
runtime, the analysis classifies the connection call as essential.

Our static analysis is designed to scale to large Android applications
and to conservatively approximate the behavior of dynamic constructs
such as reflection and missing semantics such as native methods.  The
analysis also reasons about application code reachable through Android
API calls and callbacks by analyzing each application in the context
of a rich model of the Android
API~\cite{Gordon:Kim:Perkins:Gilham:Nguyen:Rinard:NDSS15}.  Finally,
the analysis conservatively calculates the set of application methods
could be invoked by the Android runtime for determining exceptions
that could cause program exit.


There are two special cases that our technique is not designed to handle: (1) \emph{optional} behaviors, for which failing connections are silently ignored, but successful connections result in presenting additional information to the user; 
advertisement content usually falls into that category. (2) \emph{Statefull} communication, for which failures leave the 
connection target in a state different from the one it has after a successful communication, and further communication is influenced by the server's state. Our experiments show that such cases are rare. 

%
%We claim that these connections, hidden from the user, are indicative for potential unexpected operations performed by an application.
 
%Targets are not indicative, AppFence case. We show that most malware writers basically
%copy/paste code from fellow developer code and from
%public tutorials/samples from the Web~\cite{Allix:Jerome:Bissyande:Klein:State:Traon:COMPSAC14}

%We empirically analyze xx android applications from the list of yy most popular free applications on GooglePlay, focusing on the impact of successes / failures to establish connection on the overall behavior of the analyzed application. 
%The analysis reveals that applications ``silently'' handle the majority of connection failures by discarding connection error without producing any visible effect on the user-observable application functionality.  In fact, only zz\% of the triggered connection sites propagate information about a failure (or, dually, a success) of that operation to the user.


\vspace{0.1in}
\noindent 
{\bf RQ3: How well does static detection perform?}
To assess the quality of our technique, we evaluate it on the ``truth set'' established during our empirical analysis of applications from Google Play.
The results show that it features a high precision -- 83\% of the identified connection (64 out of 82) are indeed classified as non-essential during the manual analysis. Even though it is designed to be conservative, it is still able to identifying  64\% of all non-essential connection (64 out of 106).
There are 18 connections in total that are miss-classified as non-essential. Out of these, 16 correspond to optional application behaviors and the remaining 2 -- to statefull communication. Counting advertisement content as non-essential
gives the overall precision and recall of 90\% and 65\%, respectively.  

\vspace{0.1in}
\noindent 
{\bf RQ4: How often does non-essential communication occur in real-life applications and what are its most common destinations?}
Applying the analysis on additional 500 top-popular applications from Google Play reveals that 84\% of connection sites established by these applications can be deemed non-essential.
Most common target of non-essential communication are various Google services for mobile developers. We conjecture 
that applications commonly register for various such services without eventually using them. 
Additional common targets are advertisement, analytics and gaming services. 

\vspace{0.1in}
\noindent 
{\bf Significance of the Work.}
Our work focuses on benign  mobile applications that can be downloaded from popular application stores and that are installed by thousands, if not millions, of users.
By identifying and highlighting application functionality hidden from the user, it aims at improving transparency and, ultimately, quality of these applications. 
 
We are largely inspired by the positive trend of improvement that we recently observed in the application development community.
One of its manifestations is the increased awareness of privacy considerations. It is likely that such awareness was affected by multiple studies that highlighted
potential privacy violation in applications from popular application stores~\cite{Enck:Gilbert:Chun:Cox:Jung:McDaniel:Sheth:OSDI10, Egele:Kruegel:Kirda:Vign:NDSS11,Tripp:Rubin:SEC14}.
Indeed, we observed that newer versions of the analyzed applications in many cases no longer exhibit the previously identified privacy breaches.  
This improvement trend reassures and further emphasizes the significance of this work as an additional step towards achieving better application quality and increasing trust between users and application developers. 

%Giving mobile application users control over the different types of communication  believe that user should have control on the levels of application developers  
%Our ultimate goal is gradual functionality disabling


%Furthermore, applying our classification and blocking technique to 12 app that were identified as leaking sensitive information in a previous study~\cite{Tripp:Rubin:SEC14} classified all information transfers as non-essential and produced a version of each application that is equivalent to the original one, but does not leak any sensitive information.


\vspace{0.1in}
\noindent 
{\bf Contributions.}
The paper makes the following contributions:
\begin{enumerate}
\item It sets a new problem of distinguishing between essential and non-essential release of information by mobile applications in an automated manner. This problem is orthogonal and complementary to that of identifying sensitive information flow, which was the focus of numerous earlier works. 
Highlighting non-essential information releases in existing mobile applications is expected to improve transparency and contribute to the overall quality of the field. 
%Put together, the two allow establishing practically useful, \emph{differential}  privacy: the applications can be restricted to using private information only ``when needed'', without leaking it to unauthorized parties.
\item It proposes a dynamic approach for detecting non-essential releases of information in Android applications which does not require access to the application source code. 
The approach relies on interactive injection of connection failures and identification of cases in which the injected failures do not affect the observable application functionality. 
\item It provides empirical evidence for the prevalence of such non-essential connections in real-life applications. Specifically, it shows that 65\% of the connections attempted by ten top-popular free applications on Google Play fall into that category.    
\item It proposes a static technique that operates on application binaries and identifies non-essential connections -- those where failures are not propagated back to the application's user. The precision and recall of the technique is 83\% and 63\%, respectively, when evaluated against the empirically established truth set. 
The precision and recall increases to 90\% and 64\%, receptively, when considering the advertisement content as non-essential.
\item It investigate the amount of non-essential information in the 500 top-popular free applications on Google Play, showing that 84\% of connections made by these applications can be 
deemed as non-essential.
\end{enumerate}

The remainder of the paper is structured as follows. Section~\ref{sec:study} describes the empirical study we conducted for gaining insight into the nature of information releases in mobile applications. Section~\ref{sec:analysis} presents the static analysis technique designed for identifying non-essential information releases. 
Section~\ref{sec:evaluation} discusses results of its evaluation on real-live examples. Section~\ref{sec:limitations} discusses the limitations and threats to validity of our work. Section~\ref{sec:related} presents the related work, while Section~\ref{sec:conclusions} concludes. 



